// End-to-end integration tests for database operations
// Tests complete user profile and analysis workflows

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { DatabaseService } from '../../database-service';
import { ProfileRepository } from '../../repositories/profile-repository';
import { AnalysisRepository } from '../../repositories/analysis-repository';
import { RLSEnforcer } from '../../security/rls-enforcer';
import { supabase } from '../../../supabase';
import { CreateAnalysisInput } from '../../../../types/database';

// Mock Supabase with a robust, chainable factory
vi.mock('../../../supabase', () => {
  const mockSupabaseChain = {
    insert: vi.fn().mockReturnThis(),
    select: vi.fn().mockReturnThis(),
    update: vi.fn().mockReturnThis(),
    delete: vi.fn().mockReturnThis(),
    eq: vi.fn().mockReturnThis(),
    in: vi.fn().mockReturnThis(),
    gt: vi.fn().mockReturnThis(),
    lt: vi.fn().mockReturnThis(),
    gte: vi.fn().mockReturnThis(),
    lte: vi.fn().mockReturnThis(),
    order: vi.fn().mockReturnThis(),
    limit: vi.fn().mockReturnThis(),
    range: vi.fn().mockReturnThis(),
    single: vi.fn().mockResolvedValue({ data: null, error: null }),
    then: vi.fn((callback) => callback({ data: [], error: null })),
  };

  // Store reference globally so tests can access it
  (globalThis as any).mockSupabaseChain = mockSupabaseChain;

  return {
    supabase: {
      from: vi.fn().mockReturnValue(mockSupabaseChain),
      auth: {
        getUser: vi.fn(),
      },
      functions: {
        invoke: vi.fn(),
      },
    },
  };
});


describe('Database Integration Tests', () => {
  const testUserId = '123e4567-e89b-12d3-a456-426614174000';
  const testUserId2 = '123e4567-e89b-12d3-a456-426614174001';

  beforeEach(() => {
    vi.clearAllMocks();

    // Mock authenticated user
    (supabase.auth.getUser as any).mockResolvedValue({
      data: { user: { id: testUserId } },
      error: null,
    });

    // Reset mock chain to default behavior (but don't override single mock)
    const mockChain = (globalThis as any).mockSupabaseChain;
    if (mockChain) {
      // Don't reset single mock as tests may set up specific responses
      mockChain.order.mockResolvedValue({ data: [], error: null });
      mockChain.limit.mockResolvedValue({ data: [], error: null });
      mockChain.range.mockResolvedValue({ data: [], error: null });
      mockChain.then.mockImplementation((callback) => callback({ data: [], error: null }));
    }
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  describe('Complete User Workflow', () => {
    it('should handle complete user initialization and analysis creation', async () => {
      // Mock profile creation
      const mockProfile = {
        id: testUserId,
        encrypted_google_api_key: null,
        created_at: '2024-01-01T00:00:00Z',
        updated_at: '2024-01-01T00:00:00Z',
      };

      const mockAnalysis = {
        id: 1,
        user_id: testUserId,
        created_at: '2024-01-01T00:00:00Z',
        ticker_symbol: 'AAPL',
        analysis_context: 'investment' as const,
        trading_timeframe: null,
        synthesis_score: 85,
        convergence_factors: [],
        divergence_factors: [],
        full_report: { summary: 'Test analysis summary with sufficient detail' },
      };

      // Mock Supabase operations for different tables
      (supabase.from as any).mockImplementation((table: string) => {
        const mockChain = (globalThis as any).mockSupabaseChain;
        if (table === 'profiles') {
          return {
            ...mockChain,
            single: vi.fn().mockResolvedValue({ data: mockProfile, error: null }),
            update: vi.fn().mockReturnThis(),
            eq: vi.fn().mockReturnThis(),
          };
        } else if (table === 'analyses') {
          return {
            ...mockChain,
            single: vi.fn().mockResolvedValue({ data: mockAnalysis, error: null }),
            order: vi.fn().mockReturnThis(),
            limit: vi.fn().mockResolvedValue({ data: [mockAnalysis], error: null }),
            then: vi.fn((callback: any) => callback({ data: [mockAnalysis], error: null })),
          };
        }
        return mockChain;
      });

      // Step 1: Initialize user
      const profile = await DatabaseService.initializeUser(testUserId);
      expect(profile).toEqual(mockProfile);

      // Step 2: Create analysis
      const analysisInput: CreateAnalysisInput = {
        ticker_symbol: 'AAPL',
        analysis_context: 'investment',
        synthesis_score: 85,
        convergence_factors: [],
        divergence_factors: [],
        full_report: { summary: 'Test analysis summary with sufficient detail' },
      };

      const analysis = await DatabaseService.createAnalysisWithValidation(testUserId, analysisInput);
      expect(analysis).toEqual(mockAnalysis);

      // Step 3: Get user dashboard
      const dashboardData = await DatabaseService.getAnalysisDashboard(testUserId);
      expect(dashboardData.analyses).toEqual([mockAnalysis]);
      expect(dashboardData.uniqueTickers).toEqual(['AAPL']);

      // Verify operations were called
      expect(supabase.from).toHaveBeenCalledWith('profiles');
      expect(supabase.from).toHaveBeenCalledWith('analyses');
    });

    it('should handle user profile updates with API key encryption', async () => {
      const mockProfile = {
        id: testUserId,
        encrypted_google_api_key: 'encrypted_key_123',
        created_at: '2024-01-01T00:00:00Z',
        updated_at: '2024-01-02T00:00:00Z',
      };

      // Mock encryption
      (supabase.functions.invoke as any).mockResolvedValue({
        data: { encrypted_key: 'encrypted_key_123' },
        error: null,
      });

      const mockChain = (globalThis as any).mockSupabaseChain;
      mockChain.single.mockResolvedValue({ data: mockProfile, error: null });

      const updatedProfile = await DatabaseService.updateUserProfile(testUserId, {
        google_api_key: 'test_api_key',
      });

      expect(updatedProfile).toEqual(mockProfile);
      expect(supabase.functions.invoke).toHaveBeenCalledWith('encrypt-api-key', {
        body: { api_key: 'test_api_key' },
      });
    });
  });

  describe('Multi-User Data Isolation', () => {
    it('should enforce data isolation between users', async () => {
      // Mock RLS enforcement
      vi.spyOn(RLSEnforcer, 'canAccessProfile').mockImplementation(
        async (profileId, userId) => profileId === userId
      );

      vi.spyOn(RLSEnforcer, 'canAccessAnalysis').mockImplementation(
        async (analysisId, userId) => {
          // Simulate analysis ownership check
          return userId === testUserId; // Only testUserId owns analysis 1
        }
      );

      // User 1 can access their own profile
      const canAccessOwnProfile = await RLSEnforcer.canAccessProfile(testUserId, testUserId);
      expect(canAccessOwnProfile).toBe(true);

      // User 1 cannot access User 2's profile
      const canAccessOtherProfile = await RLSEnforcer.canAccessProfile(testUserId2, testUserId);
      expect(canAccessOtherProfile).toBe(false);

      // User 1 can access their own analysis
      const canAccessOwnAnalysis = await RLSEnforcer.canAccessAnalysis(1, testUserId);
      expect(canAccessOwnAnalysis).toBe(true);

      // User 2 cannot access User 1's analysis
      const canAccessOtherAnalysis = await RLSEnforcer.canAccessAnalysis(1, testUserId2);
      expect(canAccessOtherAnalysis).toBe(false);
    });

    it('should handle concurrent user operations safely', async () => {
      const mockProfile1 = {
        id: testUserId,
        encrypted_google_api_key: null,
        created_at: '2024-01-01T00:00:00Z',
        updated_at: '2024-01-01T00:00:00Z',
      };

      const mockProfile2 = {
        id: testUserId2,
        encrypted_google_api_key: null,
        created_at: '2024-01-01T00:00:00Z',
        updated_at: '2024-01-01T00:00:00Z',
      };

      (supabase.from as any).mockImplementation(() => {
        const mockChain = (globalThis as any).mockSupabaseChain;
        return {
          ...mockChain,
          single: vi.fn()
            .mockResolvedValueOnce({ data: mockProfile1, error: null })
            .mockResolvedValueOnce({ data: mockProfile2, error: null }),
        };
      });

      // Simulate concurrent user initialization
      const [profile1, profile2] = await Promise.all([
        DatabaseService.initializeUser(testUserId),
        DatabaseService.initializeUser(testUserId2),
      ]);

      expect(profile1.id).toBe(testUserId);
      expect(profile2.id).toBe(testUserId2);
      expect(mockChain.insert).toHaveBeenCalledTimes(2);
    });
  });

  describe('Complex Analysis Workflows', () => {
    it('should handle bulk analysis operations', async () => {
      const mockAnalyses = [
        {
          id: 1,
          user_id: testUserId,
          ticker_symbol: 'AAPL',
          analysis_context: 'investment' as const,
          synthesis_score: 85,
        },
        {
          id: 2,
          user_id: testUserId,
          ticker_symbol: 'TSLA',
          analysis_context: 'trading' as const,
          synthesis_score: 70,
        },
        {
          id: 3,
          user_id: testUserId,
          ticker_symbol: 'MSFT',
          analysis_context: 'investment' as const,
          synthesis_score: 90,
        },
      ];

      (supabase.from as any).mockImplementation(() => {
        const mockChain = (globalThis as any).mockSupabaseChain;
        return {
          ...mockChain,
          order: vi.fn().mockReturnThis(),
          limit: vi.fn().mockResolvedValue({ data: mockAnalyses, error: null }),
        };
      });

      const dashboard = await DatabaseService.getAnalysisDashboard(testUserId);

      expect(dashboard.analyses).toHaveLength(3);
      expect(dashboard.uniqueTickers).toEqual(['AAPL', 'TSLA', 'MSFT']);
      expect(dashboard.averageScore).toBe(82); // (85 + 70 + 90) / 3 = 81.67 -> 82
    });

    it('should handle analysis filtering and pagination', async () => {
      const mockFilteredAnalyses = [
        {
          id: 1,
          user_id: testUserId,
          ticker_symbol: 'AAPL',
          analysis_context: 'investment' as const,
          synthesis_score: 85,
        },
      ];

      (supabase.from as any).mockImplementation(() => {
        const mockChain = (globalThis as any).mockSupabaseChain;
        return {
          ...mockChain,
          range: vi.fn().mockResolvedValue({ data: mockFilteredAnalyses, error: null }),
        };
      });

      const repository = new AnalysisRepository();
      const analyses = await repository.findByUserAndContext(testUserId, 'investment', {
        limit: 10,
        offset: 0,
      });

      expect(analyses).toEqual(mockFilteredAnalyses);
      expect(mockChain.eq).toHaveBeenCalledWith('user_id', testUserId);
      expect(mockChain.eq).toHaveBeenCalledWith('analysis_context', 'investment');
    });
  });

  describe('Error Recovery and Resilience', () => {
    it('should handle database connection failures gracefully', async () => {
      const connectionError = new Error('Connection failed');
      (supabase.from as any).mockImplementation(() => {
        throw connectionError;
      });

      await expect(DatabaseService.initializeUser(testUserId)).rejects.toThrow(
        'Failed to initialize user'
      );
    });

    it('should handle partial operation failures', async () => {
      // Mock profile creation success but analysis creation failure
      const mockProfile = {
        id: testUserId,
        encrypted_google_api_key: null,
        created_at: '2024-01-01T00:00:00Z',
        updated_at: '2024-01-01T00:00:00Z',
      };

      (supabase.from as any).mockImplementation((table: string) => {
        const mockChain = (globalThis as any).mockSupabaseChain;
        if (table === 'profiles') {
          return {
            ...mockChain,
            single: vi.fn().mockResolvedValue({ data: mockProfile, error: null }),
          };
        } else if (table === 'analyses') {
          return {
            ...mockChain,
            single: vi.fn().mockResolvedValue({
              data: null,
              error: { message: 'Analysis creation failed' },
            }),
          };
        }
        return mockChain;
      });

      // Profile creation should succeed
      const profile = await DatabaseService.initializeUser(testUserId);
      expect(profile).toEqual(mockProfile);

      // Analysis creation should fail
      const analysisInput: CreateAnalysisInput = {
        ticker_symbol: 'AAPL',
        analysis_context: 'investment',
        synthesis_score: 85,
        convergence_factors: [],
        divergence_factors: [],
        full_report: { summary: 'Test analysis summary with sufficient detail' },
      };

      await expect(
        DatabaseService.createAnalysisWithValidation(testUserId, analysisInput)
      ).rejects.toThrow('Failed to create analysis');
    });
  });

  describe('Performance and Scalability', () => {
    it('should handle large datasets efficiently', async () => {
      // Mock large dataset
      const largeDataset = Array.from({ length: 1000 }, (_, i) => ({
        id: i + 1,
        user_id: testUserId,
        ticker_symbol: `STOCK${i}`,
        analysis_context: i % 2 === 0 ? 'investment' as const : 'trading' as const,
        synthesis_score: Math.floor(Math.random() * 100),
      }));

      (supabase.from as any).mockImplementation(() => {
        const mockChain = (globalThis as any).mockSupabaseChain;
        return {
          ...mockChain,
          order: vi.fn().mockReturnThis(),
          limit: vi.fn().mockResolvedValue({ data: largeDataset, error: null }),
        };
      });

      const startTime = Date.now();
      const dashboard = await DatabaseService.getAnalysisDashboard(testUserId);
      const executionTime = Date.now() - startTime;

      expect(dashboard.analyses).toHaveLength(1000);
      expect(executionTime).toBeLessThan(1000); // Should complete within 1 second
    });

    it('should handle concurrent operations without conflicts', async () => {
      const mockAnalysis = {
        id: 1,
        user_id: testUserId,
        ticker_symbol: 'AAPL',
        analysis_context: 'investment' as const,
        synthesis_score: 85,
      };

      (supabase.from as any).alThis as any).mockSupabaseChain;
    mockChain.single.mockResolvedValue({ data: mockAnalysis, error: null });

    const analysisInput: CreateAnalysisInput = {
      ticker_symbol: 'AAPL',
      analysis_context: 'investment',
      synthesis_score: 85,
      convergence_factors: [],
      divergence_factors: [],
      full_report: { summary: 'Test analysis summary with sufficient detail' },
    };

    // Simulate concurrent analysis creation
    const concurrentOperations = Array.from({ length: 10 }, () =>
      DatabaseService.createAnalysisWithValidation(testUserId, analysisInput)
    );

    const results = await Promise.all(concurrentOperations);
    expect(results).toHaveLength(10);
    results.forEach(result => {
      expect(result).toEqual(mockAnalysis);
    });
  });
});

describe('Data Consistency and Integrity', () => {
  it('should maintain referential integrity', async () => {
    // Test that analysis cannot be created without valid profile
    const analysisInput: CreateAnalysisInput = {
      ticker_symbol: 'AAPL',
      analysis_context: 'investment',
      synthesis_score: 85,
      convergence_factors: [],
      divergence_factors: [],
      full_report: { summary: 'Test analysis summary with sufficient detail' },
    };

    // Mock profile not found
    const mockChain = (globalThis as any).mockSupabaseChain;
    mockChain.single.mockResolvedValue({
      data: null,
      error: { code: 'PGRST116', message: 'No rows found' },
    });

    await expect(
      DatabaseService.createAnalysisWithValidation(testUserId, analysisInput)
    ).rejects.toThrow('User profile not found');
  });

  it('should handle cascade deletes properly', async () => {
    // Mock profile deletion
    const mockChain = (globalThis as any).mockSupabaseChain;
    mockChain.eq.mockResolvedValue({ error: null });

    const repository = new ProfileRepository();
    await repository.delete(testUserId);

    expect(mockChain.delete).toHaveBeenCalled();
    expect(mockChain.eq).toHaveBeenCalledWith('id', testUserId);
  });
});
});